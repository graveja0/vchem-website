---
title: "On the Discrete Choice of Health Care Providers"
subtitle: "Part TK: Simulating A DGP"
author: John A. Graves, Ph.D.
date: "2023-01-16"
categories: [Health Economics]
editor_options: 
  chunk_output_type: console
execute:
  echo: true
  message: false
  warning: false  
  code-fold: true
  freeze: auto 
bibliography: "references.bib"
reference-location: margin
self-contained: true
image: "media/DALY-image.svg"
editor: 
  markdown: 
    wrap: 72
---

# Introduction

This is the second part of a series of posts on the discrete choice of health care providers. In the first part, we introduced the gravity model of spatial interaction and showed how it can be used to model the discrete choice of health care providers. In this post, we will simulate a data generating process (DGP) for a gravity model of spatial interaction. We will then use this simulated data to estimate the parameters of the model using maximum likelihood estimation (MLE).



```{r setup}
#| code-fold: true
#| code-summary: Setup code
#| message: false
#| warning: false

needed_packages <- c("tidyverse","glue","progress","here","evd","geosphere","mlogit","dfidx",
                     "Formula","hrbrthemes","survival","furrr","progressr","tictoc","mcreplicate",
                     "flextable", "broom")

have <- rownames(installed.packages())
needed <- setdiff(needed_packages, have)

please_install <- function(pkgs, install_fun = install.packages) {
    
    if (length(pkgs) == 0) {
        return(invisible())
    }
    if (!interactive()) {
        stop("Please run in interactive session", call. = FALSE)
    }
    
    title <- paste0(
        "Ok to install these packges?\n",
        paste("* ", pkgs, collapse = "\n")
    )
    ok <- menu(c("Yes", "No"), title = title) == 1
    
    if (!ok) {
        return(invisible())
    }
    
    install_fun(pkgs,dependencies=TRUE)
}
please_install(needed)
x <- suppressMessages(lapply(needed_packages, require, character.only = TRUE))

options("scipen" = 100, "digits" = 5)
select <- dplyr::select

map_progress <- function(.x, .f, ..., .id = NULL) {
    # Source: https://www.jamesatkins.net/post/2020/progress-bar-in-purrrmap_df/
    .f <- purrr::as_mapper(.f, ...)
    pb <- progress::progress_bar$new(total = length(.x), force = TRUE)
    
    f <- function(...) {
        pb$tick()
        .f(...)
    }
    purrr::map(.x, f, ..., .id = .id)
}


map_multicore <- function(.x, .f, ..., .id = NULL) {
    .f <- purrr::as_mapper(.f, ...)
    p <- progressor(steps = length(.x))
    f <- function(...) {
        p()
        .f(...)
    }
    furrr::future_map(.x, f, ..., .id = .id)
}
```

## Location Data

```{r locations}
#| code-fold: true
#| code-summary: Location data code
#| message: false
#| warning: false
df_aha <-
    tibble::tribble(
        ~hosp_x, ~hosp_y, ~hosp_id,
        -87.0657, 36.2772,       1L,
        -86.8092, 36.1537,       2L,
        -86.3273, 36.2207,       3L,
        -85.7428, 35.7001,       4L,
        -84.6072, 35.4408,       5L,
        -85.2674, 35.0345,       6L,
        -82.5143, 36.5509,       7L,
        -89.7143, 35.0494,       8L,
        -85.2604, 35.0413,       9L,
        -86.8037, 36.1417,      10L,
        -81.7977, 36.4534,      11L,
        -86.5656, 35.9751,      12L,
        -89.8005,  35.207,      13L,
        -86.8035, 36.1551,      14L,
        -88.9997, 35.2668,      15L,
        -82.2567, 36.5857,      16L,
        -83.2152, 36.5334,      17L,
        -86.6081, 36.1764,      18L,
        -84.8694, 35.1775,      19L,
        -85.2906,  35.049,      20L,
        -88.1081, 36.0551,      21L,
        -85.9501, 36.2634,      22L,
        -87.4591, 35.7794,      23L,
        -87.2705,  36.582,      24L,
        -87.0665,  35.607,      25L,
        -85.5094, 36.1712,      26L,
        -89.6782, 35.5359,      27L,
        -85.0186, 35.9392,      28L,
        -84.9819, 35.5307,      29L,
        -87.3757, 36.0734,      30L,
        -82.2499, 36.3461,      31L,
        -89.3799,  36.048,      32L,
        -82.4127, 36.1334,      33L,
        -86.5554, 35.1496,      34L,
        -86.818,  35.916,      35L,
        -86.4325, 36.3908,      36L,
        -82.7904, 36.1741,      37L,
        -82.846, 36.1514,      38L,
        -84.556, 35.8884,      39L,
        -86.1682, 36.3878,      40L,
        -83.5191, 36.1065,      41L,
        -84.128,  36.576,      42L,
        -82.3842, 36.3077,      43L,
        -82.5548,  36.554,      44L,
        -82.4022, 36.3361,      45L,
        -83.9366, 35.9575,      46L,
        -84.1007, 35.9172,      47L,
        -83.9482, 35.9347,      48L,
        -86.0248, 36.5192,      49L,
        -84.1118, 36.3889,      50L,
        -87.3387,  35.219,      51L,
        -86.7857,  35.464,      52L,
        -88.3986, 35.6553,      53L,
        -85.3284, 36.3847,      54L,
        -87.8639, 35.5922,      55L,
        -84.27,  35.825,      56L,
        -86.084, 35.4687,      57L,
        -88.8686, 36.3347,      58L,
        -83.9587, 35.7565,      59L,
        -89.8586, 35.1287,      60L,
        -90.0319, 35.1426,      61L,
        -86.6216,  36.325,      62L,
        -90.0259, 35.1437,      63L,
        -90.0194, 35.1368,      64L,
        -89.9322, 35.0672,      65L,
        -89.8646, 35.0981,      66L,
        -88.7535, 35.9133,      67L,
        -83.3056, 36.2131,      68L,
        -82.3731, 36.3112,      69L,
        -86.4251, 35.8609,      70L,
        -86.8025, 36.1539,      71L,
        -86.8071, 36.1668,      72L,
        -86.7572, 36.2409,      73L,
        -86.7215, 36.0764,      74L,
        -86.8445, 36.1293,      75L,
        -86.8018, 36.1413,      76L,
        -83.1821, 35.9644,      77L,
        -84.2455, 36.0243,      78L,
        -88.3106, 36.2965,      79L,
        -88.1232,  35.636,      80L,
        -85.1935, 35.6043,      81L,
        -87.0061,  35.192,      82L,
        -83.0144, 36.3999,      83L,
        -88.2303, 35.2285,      84L,
        -83.5357, 35.8558,      85L,
        -86.0898, 35.1763,      86L,
        -86.4488, 35.5636,      87L,
        -85.4783, 35.9489,      88L,
        -86.8871, 36.4782,      89L,
        -84.4643, 35.6002,      90L,
        -83.5725, 36.4529,      91L,
        -86.2316, 35.3822,      92L,
        -89.0447, 36.4144,      93L,
        -87.795, 36.0785,      94L,
        -87.7564, 35.3252,      95L,
        -86.0721, 35.8326,      96L,
        -88.832, 35.6367,      97L,
        -87.6896, 36.3202,      98L,
        -88.412, 36.0229,      99L,
        -85.8295, 35.9615,     100L,
        -84.5159, 36.5044,     101L
    )

loc <-
    tibble::tribble(
        ~zip,        ~y,         ~x,
        37206L, 36.180173, -86.742066,
        37207L,  36.22225, -86.775085,
        37208L, 36.176866,  -86.80786,
        37209L, 36.148024, -86.869685,
        37210L,  36.13844, -86.739265,
        37211L, 36.067522, -86.721219,
        37212L, 36.135333,  -86.79993,
        37213L, 36.169674, -86.769617,
        37214L, 36.165693,  -86.65909,
        37215L, 36.096895, -86.824092,
        37216L, 36.212995, -86.726085,
        37217L, 36.107141, -86.668089,
        37218L, 36.207631, -86.846454,
        37219L, 36.164516, -86.781539,
        37220L, 36.066135, -86.772465,
        37221L, 36.068319, -86.949648,
        37228L,  36.19026, -86.804031,
        37240L, 36.144748, -86.805258,
        37201L, 36.166419, -86.778182,
        37203L, 36.146286, -86.792457,
        37204L,  36.11175, -86.784663,
        37205L, 36.113509, -86.862533
    ) %>%
    mutate(zip = paste0(zip))
location_ <- unique(loc$zip)
```

## Paramterize the Data Generation Process

```{r}
params <- list(
    N = 1000,              # Number of patients
    H = nrow(df_aha) ,     # Number of hospitals
    J = 20,                # Number of plans
    K = 10      ,          # Number of networks
    mu = list(intercept = 1,
              mu_x_i = 0.5,  # coef on patient attribute
              mu_q_h = 6,    # coef on hospital attribute
              mu_d_gh = -1,  # coef of distance
              mu_hmo_not_in_network = 5,  # coef on out-of-network HMO
              mu_ppo_not_in_network = 3), # coef on out-of-network PPO
    eta = list(eta_intercept = -1,
               eta_h_k = 10),
    beta_q_h = .05
)
```


## Define the Data Generation Process

```{r}
#| code-fold: true
#| code-summary: Define a function to generate hospital attributes
#| 
generate_hospital_attributes <- function(params) {
 with(params,{
        # Hospital-level variables
            data.frame(hosp_id = 1:H, q_h = rnorm(H,0,1)) %>%
            mutate(q_h = percent_rank(q_h)) %>%
            as_tibble()
 })
}

hosp_ <- params %>% generate_hospital_attributes()
hosp_ %>% 
    head(n = 5) %>% 
    flextable() %>% 
    theme_vanilla()
```

```{r}
#| code-fold: true
#| code-summary: Define a function to calculate distance between patients and hospitals

generate_distance_data <- function(params, hosp_data) {
     with(params,{
     crossing(zip = loc$zip ,hosp_id = hosp_data$hosp_id) %>%
            as_tibble() %>%
            left_join(loc,"zip") %>%
            left_join(df_aha,"hosp_id") %>%
            rowwise() %>%
            mutate(dist = as.vector(distm(c(x,y),c(hosp_x,hosp_y), fun = distHaversine)*0.000621371)) %>%
            select(zip,hosp_id,dist) %>%
            set_names(c("zip","hosp_id","d_gh")) %>%
            data.frame() %>%
            dplyr::filter(d_gh < 50000) %>%
            as_tibble()
     })
}

dist_ <- params %>% generate_distance_data(hosp_data = hosp_)
dist_ %>% 
    head(n = 5) %>% 
    flextable() %>% 
    theme_vanilla()
           
```

```{r}
#| code-fold: true
#| code-summary: Define functions to generate network and plan attributes

generate_network_data <- function(params, hosp_data) {
     with(params,{
       net_0 <-
            tibble(network_id = paste0("K_",1:K)) %>%
            crossing(hosp_id = hosp_data$hosp_id)  %>%
            left_join(hosp_, "hosp_id") %>%
            ########################################################################################
            # NETWORK SELECTION MODEL: HIGHER QUALITY HOSPITALS ARE MORE LIKELY TO BE IN-NETWORK
            ########################################################################################
            mutate(xb = -2 + q_h + rnorm(n(),mean=2,sd=1)) %>%
                mutate(pr_in = boot::inv.logit(xb)) %>%
                rowwise() %>%
                mutate(in_network = rbinom(1,1,prob = pr_in)) %>%
            ########################################################################################
            select(network_id,hosp_id, in_network) %>%
                ungroup()
        
        net_ <-
            net_0 %>%
            left_join(
                net_0 %>%
                    left_join(hosp_data,"hosp_id") %>%
                    filter(in_network==1) %>%
                    group_by(network_id) %>%
                    summarise(net_qual_list = mean(q_h)),"network_id"
            )
    return(net_)
     })

}

net_ <- params %>% generate_network_data(hosp_data = hosp_)

net_ %>% 
    head(n=5) %>% 
    flextable()
 
generate_plan_data <- function(params, network_data) {
     with(params,{
         
        breadth <-
            net_ %>%
            group_by(network_id) %>%
            summarise(breadth = mean(in_network)) %>%
            mutate(narrower = as.integer(percent_rank(breadth)<.5))
        
        hmo_nets <- breadth[breadth$narrower==1,]$network_id
        ppo_nets <- breadth[breadth$narrower==0,]$network_id
        
        plan <-
            tibble(plan_id = paste0("P_",1:J)) %>%
            rowwise() %>%
            mutate(type = sample(c("HMO","PPO"),1,prob = c(.75, 0.25))) %>%
            mutate(network_id = ifelse(type=="HMO",sample(hmo_nets,1),sample(ppo_nets,1))) 
        
        return(plan)
     })
}

plan_ <- params %>% generate_plan_data(network_data = net_)
     
plan_ %>% 
    head(n=5) %>% 
    flextable()
```

## Combine Hospital, Patient, Plan and Network Attributes

```{r}
#| code-fold: true
#| code-summary: Construct final attribute data

combine_attributes <- function(params,hosp_data, location_data , dist_data, plan_data, network_data) {
    with(params,{
        df_choice <-
            data.frame(patient_id = 1:N, x_i = rnorm(N,0,1),runif = runif(N,min=0,max=1)) %>%
            as_tibble() %>%
            rowwise() %>%
            # Sample patient residence from ZIPs
            mutate(zip = sample(location_data,size =1, prob = rep(1/length(location_data),length(location_data)))) %>%
            mutate(plan_id = sample(size = 1, x = unique(plan_data$plan_id), prob = rep(1/J,J))) %>%
            left_join(plan_data,"plan_id") %>%
            ###################################################################################################
            ## IN THIS CASE, PATIENTS RANDOMLY SELECT PLAN
            ###################################################################################################
            # Merge in choice set
            left_join(dist_data , "zip", relationship = "many-to-many") %>%
                left_join(hosp_data,"hosp_id") %>%
                left_join(network_data, c("hosp_id","network_id")) %>%
                mutate(not_in_network = 1 - in_network) %>%
                mutate(hmo = as.integer(type=="HMO")) %>% 
            select(-runif,-net_qual_list) 
        return(df_choice)
    })
}

df_choice <- params %>% 
    combine_attributes(
        hosp_data = hosp_,
        location_data = location_,
        dist_data = dist_,
        plan_data = plan_,
        network_data = net_) 
    
df_choice %>% 
    head() %>% 
    flextable()
```

## Gravity Model

```{r}
derive_choice_probabilities_gravity <- function(params, df, network=TRUE) {
    with(params, {
        if (network) {
            df %>%
                mutate(t_ih = d_gh^2 * exp(mu$mu_hmo_not_in_network * not_in_network * hmo + mu$mu_ppo_not_in_network * not_in_network * (1-hmo))) %>%
                mutate(f_ih = exp(1)*exp(x_i)^mu$mu_x_i*exp(q_h)^mu$mu_q_h /  t_ih^{-mu$mu_d_gh}) %>% 
                group_by(patient_id) %>%
                mutate(pr_g = round(f_ih / sum(f_ih),3)) %>%
                arrange(patient_id, desc(pr_g)) %>% 
                select(patient_id,hosp_id, t_ih, f_ih, pr_g)
        } else {
            df %>%
                mutate(t_ih = d_gh^2)  %>%
                mutate(f_ih = exp(1)*exp(x_i)^mu$mu_x_i*exp(q_h)^mu$mu_q_h /  t_ih^{-mu$mu_d_gh}) %>% 
                group_by(patient_id) %>%
                mutate(pr_g = round(f_ih / sum(f_ih),3)) %>%
                arrange(patient_id, desc(pr_g)) %>% 
                select(patient_id,hosp_id, t_ih, f_ih, pr_g)
        }
    })
}

choice_gravity <- 
    params %>% derive_choice_probabilities_gravity(df = df_choice, network = FALSE) 
```


## Utility Maximization

```{r}
derive_choice_probabilities_utility <- function(params, df, network = TRUE) {
    with(params, {
        if (network) {
            df %>%
                mutate(
                    u_ih = mu$intercept + mu$mu_x_i * x_i + mu$mu_q_h * q_h + mu$mu_d_gh * log(d_gh ^2) + 
                           mu$mu_d_gh * mu$mu_ppo_not_in_network * not_in_network * (1 - hmo) + 
                           mu$mu_d_gh * mu$mu_hmo_not_in_network * not_in_network * hmo 
                ) %>%
                mutate(u_ih = exp(u_ih)) %>% 
                group_by(patient_id) %>%
                mutate(pr_u = round(u_ih / sum(u_ih),3)) %>%
                arrange(patient_id, desc(pr_u)) %>% 
                select(patient_id,hosp_id, u_ih, pr_u)
        } else {
             df %>%
                mutate(
                    u_ih = mu$intercept + mu$mu_x_i * x_i + mu$mu_q_h * q_h + mu$mu_d_gh * log(d_gh ^2) 
                ) %>%
                mutate(u_ih = exp(u_ih)) %>% 
                group_by(patient_id) %>%
                mutate(pr_u = round(u_ih / sum(u_ih),3)) %>%
                arrange(patient_id, desc(pr_u)) %>% 
                select(patient_id,hosp_id, u_ih, pr_u)
        }
        
    })
}

choice_utility <- 
    params %>% derive_choice_probabilities_utility(df = df_choice, network = FALSE) 
```


```{r}
#| code-fold: true
#| code-summary: Construct table

choice_gravity %>% 
    left_join(choice_utility,c("patient_id","hosp_id")) %>% 
    filter(pr_g>0.02) %>% 
    head(n=10) %>% 
    flextable(col_keys = c("patient_id","hosp_id","tmp1","t_ih","f_ih","pr_g","tmp2","u_ih","pr_u")) %>% 
    theme_vanilla() %>% 
    add_header_row(values = c("","","Gravity Model","","Utility Maximization"),colwidths = c(2,1,3,1,2)) %>% 
    empty_blanks() 
```


# Simulate

```{r}
simulate_dgp <- function(params, has_network = TRUE, max_distance = 50) {
    hosp_ <- params %>% generate_hospital_attributes()
    dist_ <- params %>% generate_distance_data(hosp_data = hosp_)
    net_ <- params %>% generate_network_data(hosp_data = hosp_)
    plan_ <- params %>% generate_plan_data(network_data = net_)
    df_choice <- params %>% 
        combine_attributes(
            hosp_data = hosp_,
            location_data = location_,
            dist_data = dist_,
            plan_data = plan_,
            network_data = net_)  
    
    tmp <-
        params %>% derive_choice_probabilities_gravity(df = df_choice, network = has_network)  %>%
        group_by(patient_id) %>%
        mutate(runif = runif(1)) %>%
        mutate(cum_pr = cumsum(pr_g)) %>%
        mutate(cum_pr = ifelse(row_number() == n(), 1, cum_pr)) %>%
        mutate(cum_pr0 = ifelse(row_number() == 1, 0, lag(cum_pr, 1))) %>%
        rowwise() %>%
        mutate(selected = as.integer(between(runif, cum_pr0, cum_pr))) %>%
        ungroup() %>%
        select(patient_id, hosp_id, truth = pr_g, selected) 
    
    df_choice %>% 
        left_join(tmp,c("patient_id","hosp_id")) %>% 
        ungroup() %>% 
        filter(d_gh <= max_distance) %>%
        select(patient_id, x_i, hosp_id, q_h, selected, d_gh, not_in_network, hmo, truth) %>%
        group_by(patient_id) %>%
        # Remove individuals whose selected hospital is > max_distance
        mutate(max_choice = max(selected)) %>%
        filter(max_choice == 1) %>% 
        select(-max_choice) %>% 
        # Remove hospitals that are never chosen
        group_by(hosp_id) %>% 
        mutate(max_choice = max(selected)) %>%
        filter(max_choice == 1) %>% ungroup()
}

df <- params %>%
    simulate_dgp(has_network = FALSE) 
```

```{r}
df_res <- 
    df %>% select(patient_id,hosp_id,truth)

# Conditional Logit with Hospital and Patient Fixed Effects
fit_cl <- clogit(selected ~ factor(hosp_id) + log(d_gh^2) + strata(patient_id), data = df,method=c("efron"), robust = TRUE,
                 control = coxph.control(iter.max = 1000))
coef_fit_cl <- fit_cl %>% tidy()
df_res$p_choice_cl <- predict(fit_cl,type="expected")

# Thought experiment: estimate the instantaneous hazard
fit_cox <- coxph(formula = Surv(rep(1, nrow(df)), selected) ~ factor(hosp_id) + log(d_gh^2) + strata(patient_id), 
      data = df, method = "efron")
coef_fit_cox <- fit_cox %>% tidy()
baseline_hazard <- basehaz(fit_cox) %>% as_tibble() %>% janitor::clean_names() %>% select(-time)
df_res$linear_predictor <- predict(fit_cox, type = "lp")
df_res$strata = model.frame(fit_cox) %>% as_tibble() %>% janitor::clean_names() %>% pull(strata_patient_id)
df_res <- df_res %>% left_join(baseline_hazard,"strata")
#df_res$p_choice_cox <- predict(fit_cox,type="expected")
df_res <- 
    df_res %>% mutate(p_choice_cox = exp(linear_predictor)*hazard) %>% 
    group_by(patient_id) %>% 
    mutate(p_choice_cox = p_choice_cox/sum(p_choice_cox))  %>% 
    select(patient_id,hosp_id,truth,p_choice_cl,p_choice_cox)

df_res %>% 
    gather(model,p_choice,-patient_id,-hosp_id,-truth) %>% 
    mutate(model = case_when(model=="p_choice_cl" ~ "Conditional Logit",
                             model=="p_choice_cox" ~ "Cox Proportional Hazards")) %>% 
    ggplot(aes(x = truth, y = p_choice, colour = model)) + geom_smooth() + 
    hrbrthemes::theme_ipsum() + 
    geom_abline(intercept = 0, slope = 1, lty=2) + 
    theme(legend.position = "bottom") + 
    ggsci::scale_colour_nejm(name="") +
    labs(x = "Chioce Probability: Truth", y = "Choice Probability: Prediccted") + 
    geom_point(alpha=0.2)


#basehaz(fit_cox) %>% as_tibble() 
#model.frame(fit_cox) %>% 
#    as_tibble()
# coef_fit_cl %>% filter(grepl("d_gh",term))
# coef_fit_cox %>% filter(grepl("d_gh",term))

# Conditional Logit with  Patient Fixed Effects and Hospital Attributes
fit_clx <- clogit(selected ~  q_h + log(d_gh^2) + strata(patient_id) , data = df, method = c("efron"), robust = TRUE)
coef_fit_clx <- fit_clx %>% tidy()
```

# Scratch

```{r, eval = FALSE}
est_choice <- function(df) {
    suppressWarnings({clogit(selected ~ factor(hosp_id) + log(d_gh^2) +  I(not_in_network*(1-hmo)) + I(not_in_network*hmo) + strata(patient_id), data = df,method=c("efron"), robust = TRUE)})
}


fit <- df %>% est_choice()

df$p_select = predict(fit, type="expected", newdata = df)

df %>% 
    ggplot(aes( x= truth, y = p_select)) + geom_point()
    
fit %>% broom::tidy() %>% filter(!grepl("hosp_id",term))


df_net <- params %>% simulate_dgp(has_network=TRUE) %>% filter(d_gh <50) %>% select(patient_id, x_i,hosp_id, q_h, selected, d_gh, not_in_network,hmo, truth)  %>% 
    group_by(patient_id) %>% mutate(max_choice = max(selected)) %>% filter(max_choice==1)
fit_net <- df_net %>% est_choice()

# df_net$p_select = predict(fit_net, type="expected", newdata = df_net)
# 
# df_net %>% 
#     ggplot(aes( x= truth, y = p_select)) + geom_point()
#     
# fit_net %>% broom::tidy() %>% filter(!grepl("hosp_id",term))
# 
# coef(fit_net)["I(not_in_network * hmo)"]/coef(fit_net)["log(d_gh^2)"]
# coef(fit_net)["I(not_in_network * (1 - hmo))"]/coef(fit_net)["log(d_gh^2)"]
# exp(coef(fit_net)["I(not_in_network * (1 - hmo))"]*coef(fit_net)["log(d_gh^2)"])
# exp(coef(fit_net)["I(not_in_network * hmo)"]*coef(fit_net)["log(d_gh^2)"])

```

# To cite

Michell H Gail, Jay H Lubin and Lawrence V Rubinstein. Likelihood calculations for matched case-control studies and survival studies with tied death times. Biometrika 68:703-707, 1980.


The statement from the clogit documentation in the survival package in R highlights an interesting connection between conditional logistic regression (used for discrete choice models) and the Cox proportional hazards model (used in survival analysis). Let's delve into this relationship:

Conditional Logistic Regression

Purpose: Conditional logistic regression is designed for matched case-control studies. In such studies, each "case" (an event of interest) is matched with one or more "controls" (similar instances where the event did not occur).

Modeling Approach: The model estimates the effect of different variables on the probability of being a case, conditional on the matched set.

Cox Proportional Hazards Model

Purpose: The Cox model is used in survival analysis to investigate the effect of various factors on the time to an event (like death, failure, etc.).

Modeling Framework: It models the hazard (the instantaneous event rate) as a function of a set of covariates without needing to specify the baseline hazard function.

The Connection

Log-Likelihood Equivalence: The log-likelihood of a conditional logistic regression model is equivalent to that of a Cox proportional hazards model under a specific data structure. This equivalence is intriguing because, on the surface, the two models serve different purposes - one for matched case-control data and the other for time-to-event data.

Data Structure: The particular data structure refers to organizing the matched case-control data in a way that is analogous to survival data. In this structure:

Each matched set in the conditional logistic model is treated like a "strata" in a Cox model.

The "event" in the Cox model corresponds to the case in the conditional logistic setup.

Time is not a factor in the analysis (or is treated as constant), as the focus is on the case-control comparison within each matched set.

Mathematical Derivation: Proving the equivalence involves showing that the partial likelihoods used in both models are the same under this data arrangement. The partial likelihood in the Cox model, which typically accounts for censoring and time-to-event, simplifies in this context to focus on the binary outcome (case vs. control) within strata.

Implications: This equivalence is beneficial because it allows for the use of Cox model computational techniques and software to fit conditional logistic regression models. It's a surprising and elegant example of how different statistical models can converge under certain conditions.

Conclusion

The equivalence between the conditional logistic regression and Cox proportional hazards models under specific conditions is a fascinating example of the interplay between different statistical methodologies. It demonstrates the versatility of statistical models and how a deep understanding of their underlying mathematics can lead to innovative applications across different types of data and research questions.


