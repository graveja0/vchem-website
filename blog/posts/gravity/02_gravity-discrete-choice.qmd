---
title: "On the Discrete Choice of Health Care Providers"
subtitle: "Part 2: Estimating on Simulated Data"
author: John A. Graves, Ph.D.
date: "2023-01-20"
categories: [Health Economics]
editor_options: 
  chunk_output_type: console
execute:
  echo: true
  message: false
  warning: false  
  code-fold: true
  freeze: auto 
  cache: true
bibliography: "references.bib"
reference-location: margin
self-contained: true
image: "media/gravity-icon.png"
editor: 
  markdown: 
    wrap: 72
---

::: {.callout-tip appearance="minimal"}
Funding for this work is graciously acknowledged from Arnold
Ventures.
:::

```{r setup}
#| code-fold: true
#| code-summary: Setup R Session
#| message: false
#| warning: false

needed_packages <- c("tidyverse","glue","progress","here","evd","geosphere","mlogit","dfidx",
                     "Formula","hrbrthemes","survival","furrr","progressr","tictoc","mcreplicate",
                     "flextable", "broom")

have <- rownames(installed.packages())
needed <- setdiff(needed_packages, have)

please_install <- function(pkgs, install_fun = install.packages) {
    
    if (length(pkgs) == 0) {
        return(invisible())
    }
    if (!interactive()) {
        stop("Please run in interactive session", call. = FALSE)
    }
    
    title <- paste0(
        "Ok to install these packges?\n",
        paste("* ", pkgs, collapse = "\n")
    )
    ok <- menu(c("Yes", "No"), title = title) == 1
    
    if (!ok) {
        return(invisible())
    }
    
    install_fun(pkgs,dependencies=TRUE)
}
please_install(needed)
x <- suppressMessages(lapply(needed_packages, require, character.only = TRUE))

options("scipen" = 100, "digits" = 5)
select <- dplyr::select

map_progress <- function(.x, .f, ..., .id = NULL) {
    # Source: https://www.jamesatkins.net/post/2020/progress-bar-in-purrrmap_df/
    .f <- purrr::as_mapper(.f, ...)
    pb <- progress::progress_bar$new(total = length(.x), force = TRUE)
    
    f <- function(...) {
        pb$tick()
        .f(...)
    }
    purrr::map(.x, f, ..., .id = .id)
}


map_multicore <- function(.x, .f, ..., .id = NULL) {
    .f <- purrr::as_mapper(.f, ...)
    p <- progressor(steps = length(.x))
    f <- function(...) {
        p()
        .f(...)
    }
    furrr::future_map(.x, f, ..., .id = .id)
}
```

# Introduction

## Paramterize the Data Generation Process

Our first step is to define the data generation process. We begin with location data on 22 ZIP codes and 101 hospitals in Tennessee. The latitude and longitude coordinates of each are provided in the code below. This information will be used later when we calculate distances between patient $i$'s residential geography ($g(i)$)  and hospital ($h$). 

```{r locations}
#| code-fold: true
#| code-summary: Location data code
#| message: false
#| warning: false
df_aha <-
    tibble::tribble(
        ~hosp_x, ~hosp_y, ~hosp_id,
        -87.0657, 36.2772,       1L,
        -86.8092, 36.1537,       2L,
        -86.3273, 36.2207,       3L,
        -85.7428, 35.7001,       4L,
        -84.6072, 35.4408,       5L,
        -85.2674, 35.0345,       6L,
        -82.5143, 36.5509,       7L,
        -89.7143, 35.0494,       8L,
        -85.2604, 35.0413,       9L,
        -86.8037, 36.1417,      10L,
        -81.7977, 36.4534,      11L,
        -86.5656, 35.9751,      12L,
        -89.8005,  35.207,      13L,
        -86.8035, 36.1551,      14L,
        -88.9997, 35.2668,      15L,
        -82.2567, 36.5857,      16L,
        -83.2152, 36.5334,      17L,
        -86.6081, 36.1764,      18L,
        -84.8694, 35.1775,      19L,
        -85.2906,  35.049,      20L,
        -88.1081, 36.0551,      21L,
        -85.9501, 36.2634,      22L,
        -87.4591, 35.7794,      23L,
        -87.2705,  36.582,      24L,
        -87.0665,  35.607,      25L,
        -85.5094, 36.1712,      26L,
        -89.6782, 35.5359,      27L,
        -85.0186, 35.9392,      28L,
        -84.9819, 35.5307,      29L,
        -87.3757, 36.0734,      30L,
        -82.2499, 36.3461,      31L,
        -89.3799,  36.048,      32L,
        -82.4127, 36.1334,      33L,
        -86.5554, 35.1496,      34L,
        -86.818,  35.916,      35L,
        -86.4325, 36.3908,      36L,
        -82.7904, 36.1741,      37L,
        -82.846, 36.1514,      38L,
        -84.556, 35.8884,      39L,
        -86.1682, 36.3878,      40L,
        -83.5191, 36.1065,      41L,
        -84.128,  36.576,      42L,
        -82.3842, 36.3077,      43L,
        -82.5548,  36.554,      44L,
        -82.4022, 36.3361,      45L,
        -83.9366, 35.9575,      46L,
        -84.1007, 35.9172,      47L,
        -83.9482, 35.9347,      48L,
        -86.0248, 36.5192,      49L,
        -84.1118, 36.3889,      50L,
        -87.3387,  35.219,      51L,
        -86.7857,  35.464,      52L,
        -88.3986, 35.6553,      53L,
        -85.3284, 36.3847,      54L,
        -87.8639, 35.5922,      55L,
        -84.27,  35.825,      56L,
        -86.084, 35.4687,      57L,
        -88.8686, 36.3347,      58L,
        -83.9587, 35.7565,      59L,
        -89.8586, 35.1287,      60L,
        -90.0319, 35.1426,      61L,
        -86.6216,  36.325,      62L,
        -90.0259, 35.1437,      63L,
        -90.0194, 35.1368,      64L,
        -89.9322, 35.0672,      65L,
        -89.8646, 35.0981,      66L,
        -88.7535, 35.9133,      67L,
        -83.3056, 36.2131,      68L,
        -82.3731, 36.3112,      69L,
        -86.4251, 35.8609,      70L,
        -86.8025, 36.1539,      71L,
        -86.8071, 36.1668,      72L,
        -86.7572, 36.2409,      73L,
        -86.7215, 36.0764,      74L,
        -86.8445, 36.1293,      75L,
        -86.8018, 36.1413,      76L,
        -83.1821, 35.9644,      77L,
        -84.2455, 36.0243,      78L,
        -88.3106, 36.2965,      79L,
        -88.1232,  35.636,      80L,
        -85.1935, 35.6043,      81L,
        -87.0061,  35.192,      82L,
        -83.0144, 36.3999,      83L,
        -88.2303, 35.2285,      84L,
        -83.5357, 35.8558,      85L,
        -86.0898, 35.1763,      86L,
        -86.4488, 35.5636,      87L,
        -85.4783, 35.9489,      88L,
        -86.8871, 36.4782,      89L,
        -84.4643, 35.6002,      90L,
        -83.5725, 36.4529,      91L,
        -86.2316, 35.3822,      92L,
        -89.0447, 36.4144,      93L,
        -87.795, 36.0785,      94L,
        -87.7564, 35.3252,      95L,
        -86.0721, 35.8326,      96L,
        -88.832, 35.6367,      97L,
        -87.6896, 36.3202,      98L,
        -88.412, 36.0229,      99L,
        -85.8295, 35.9615,     100L,
        -84.5159, 36.5044,     101L
    )

loc <-
    tibble::tribble(
        ~zip,        ~y,         ~x,
        37206L, 36.180173, -86.742066,
        37207L,  36.22225, -86.775085,
        37208L, 36.176866,  -86.80786,
        37209L, 36.148024, -86.869685,
        37210L,  36.13844, -86.739265,
        37211L, 36.067522, -86.721219,
        37212L, 36.135333,  -86.79993,
        37213L, 36.169674, -86.769617,
        37214L, 36.165693,  -86.65909,
        37215L, 36.096895, -86.824092,
        37216L, 36.212995, -86.726085,
        37217L, 36.107141, -86.668089,
        37218L, 36.207631, -86.846454,
        37219L, 36.164516, -86.781539,
        37220L, 36.066135, -86.772465,
        37221L, 36.068319, -86.949648,
        37228L,  36.19026, -86.804031,
        37240L, 36.144748, -86.805258,
        37201L, 36.166419, -86.778182,
        37203L, 36.146286, -86.792457,
        37204L,  36.11175, -86.784663,
        37205L, 36.113509, -86.862533
    ) %>%
    mutate(zip = paste0(zip))
location_ <- unique(loc$zip)
```

We next paramaterize the data generation process (DGP). The parameter vector `mu` includes the "true" value of the coefficients that will later govern our DGP. We assume that in addition to distance from home, patients highly value hospital quality ($Q_h$) in their selections. In addition, patient attributes ($X_i$) also inform hospital choice, though to a lesser extent. 

Later, we will conceptualize the idea of a provider network exerting additional frictions on the choice of hospital; this will come into play with the parameters on out-of-network HMO and PPO plans. 

```{r}
params <- list(
    N = 1000,              # Number of patients
    H = nrow(df_aha) ,     # Number of hospitals
    J = 20,                # Number of plans
    K = 10      ,          # Number of networks
    mu = list(intercept = 1,
              mu_x_i = 0.5,  # coef on patient attribute
              mu_q_h = 6,    # coef on hospital attribute
              mu_d_gh = -1,  # coef of distance
              mu_hmo_not_in_network = 5,  # coef on out-of-network HMO
              mu_ppo_not_in_network = 3)  # coef on out-of-network PPO
)
```

## Define the Data Generation Process

We begin by specifying a discrete choice model for patient $i$ selecting hospital $h$. We first consider the case where the patient is unrestricted by a provider network (e.g., as in traditional Medicare);  Using a standard random utility framework, we specify the patientâ€™s utility as 

$$
u_{i h}=\alpha_0+\alpha_1 X_i+\alpha_2 Q_h+\alpha_3 \log \left(t_{i h}\right)+v_{i h}
$$ {#eq-randutility0}
where $X_i \sim N(0,1)$ capture patient-level attributes (e.g., demographics, comorbidities, etc.), $Q_h\sim N(0,1)$ capture hospital-level attributes (e.g., measures of clinical quality), $t_{ih} = D_{g(i)h}^2$, the squared distance/travel time ($D_{g(i)h}$) between patient $i$'s geographic location (i.e., $g(i)$) and $h$, and $v_{ih}$  is an idiosyncratic error term. 

```{r}
#| code-fold: true
#| code-summary: Define functions to generate hospital attributes and distance.
#| 
generate_hospital_attributes <- function(params) {
 with(params,{
        # Hospital-level variables
            data.frame(hosp_id = 1:H, q_h = rnorm(H,0,1)) %>%
            mutate(q_h = percent_rank(q_h)) %>%
            as_tibble()
 })
}

hosp_ <- params %>% generate_hospital_attributes()

generate_distance_data <- function(params, hosp_data) {
     with(params,{
     crossing(zip = loc$zip ,hosp_id = hosp_data$hosp_id) %>%
            as_tibble() %>%
            left_join(loc,"zip") %>%
            left_join(df_aha,"hosp_id") %>%
            rowwise() %>%
            mutate(dist = as.vector(distm(c(x,y),c(hosp_x,hosp_y), fun = distHaversine)*0.000621371)) %>%
            select(zip,hosp_id,dist) %>%
            set_names(c("zip","hosp_id","d_gh")) %>%
            data.frame() %>%
            dplyr::filter(d_gh < 50000) %>%
            as_tibble()
     })
}

dist_ <- params %>% generate_distance_data(hosp_data = hosp_)
```

Later on, we'll consider the role of provider networks in shaping hospital choice. To do this, we'll assume patients are randomly assigned to one of 20 health plans that share 10 total provider networks.[^nets] Health plans offer both generous out-of-network coverage ("PPO") or restrictive out-of-network coverage ("HMO"). 

[^nets]: It is not uncommon for health plans to share the same network and differentiate across other dimensions (e.g., deductibles and cost-sharing). 

```{r}
#| code-fold: true
#| code-summary: Define functions to generate network and plan attributes

generate_network_data <- function(params, hosp_data) {
     with(params,{
       net_0 <-
            tibble(network_id = paste0("K_",1:K)) %>%
            crossing(hosp_id = hosp_data$hosp_id)  %>%
            left_join(hosp_, "hosp_id") %>%
            ########################################################################################
            # NETWORK SELECTION MODEL: HIGHER QUALITY HOSPITALS ARE MORE LIKELY TO BE IN-NETWORK
            ########################################################################################
            mutate(xb = -2 + q_h + rnorm(n(),mean=2,sd=1)) %>%
                mutate(pr_in = boot::inv.logit(xb)) %>%
                rowwise() %>%
                mutate(in_network = rbinom(1,1,prob = pr_in)) %>%
            ########################################################################################
            select(network_id,hosp_id, in_network) %>%
                ungroup()
        
        net_ <-
            net_0 %>%
            left_join(
                net_0 %>%
                    left_join(hosp_data,"hosp_id") %>%
                    filter(in_network==1) %>%
                    group_by(network_id) %>%
                    summarise(net_qual_list = mean(q_h)),"network_id"
            )
    return(net_)
     })

}

net_ <- params %>% generate_network_data(hosp_data = hosp_)

generate_plan_data <- function(params, network_data) {
     with(params,{
         
        breadth <-
            net_ %>%
            group_by(network_id) %>%
            summarise(breadth = mean(in_network)) %>%
            mutate(narrower = as.integer(percent_rank(breadth)<.5))
        
        hmo_nets <- breadth[breadth$narrower==1,]$network_id
        ppo_nets <- breadth[breadth$narrower==0,]$network_id
        
        plan <-
            tibble(plan_id = paste0("P_",1:J)) %>%
            rowwise() %>%
            mutate(type = sample(c("HMO","PPO"),1,prob = c(.75, 0.25))) %>%
            mutate(network_id = ifelse(type=="HMO",sample(hmo_nets,1),sample(ppo_nets,1))) 
        
        return(plan)
     })
}

plan_ <- params %>% generate_plan_data(network_data = net_)
```

## Combine Hospital, Patient, Plan and Network Attributes

With the above functions and data defined, we combine them all together into a "long" dataset of patients, their hospital choice set, and various patient-, plan-, hospital-, and patient-hospital-level attributes. @tbl-attributes shows the first five rows of simulated data. 

```{r}
#| code-fold: true
#| code-summary: Construct final attribute data
#| tbl-cap: First five rows of simulated data
#| label: tbl-attributes

combine_attributes <- function(params,hosp_data, location_data , dist_data, plan_data, network_data) {
    with(params,{
        df_choice <-
            data.frame(patient_id = 1:N, x_i = rnorm(N,0,1),runif = runif(N,min=0,max=1)) %>%
            as_tibble() %>%
            rowwise() %>%
            # Sample patient residence from ZIPs
            mutate(zip = sample(location_data,size =1, prob = rep(1/length(location_data),length(location_data)))) %>%
            mutate(plan_id = sample(size = 1, x = unique(plan_data$plan_id), prob = rep(1/J,J))) %>%
            left_join(plan_data,"plan_id") %>%
            ###################################################################################################
            ## IN THIS CASE, PATIENTS RANDOMLY SELECT PLAN
            ###################################################################################################
            # Merge in choice set
            left_join(dist_data , "zip", relationship = "many-to-many") %>%
                left_join(hosp_data,"hosp_id") %>%
                left_join(network_data, c("hosp_id","network_id")) %>%
                mutate(not_in_network = 1 - in_network) %>%
                mutate(hmo = as.integer(type=="HMO")) %>% 
            select(-runif,-net_qual_list) 
        return(df_choice)
    })
}

df_choice <- params %>% 
    combine_attributes(
        hosp_data = hosp_,
        location_data = location_,
        dist_data = dist_,
        plan_data = plan_,
        network_data = net_) 
    
df_choice %>% 
    head() %>% 
    flextable()
```

## Calculate Choice Probabilities

Our next step is to draw on the DGP specified in @eq-randutility0 to calculate choice probabilities for each alternative. 

### Random Utility Framework

The function `derive_choice_probabilities_utility()` takes as inputs the parameters and data defined above and applies @eq-randutility0 to calculate these probabilities. 

```{r}
#| code-fold: true
#| code-summary: Derive choice probabilities from random utility framework
#| message: false
#| warning: false

derive_choice_probabilities_utility <- function(params, df, network = TRUE) {
    with(params, {
        if (network) {
            df %>%
                mutate(
                    u_ih = mu$intercept + mu$mu_x_i * x_i + mu$mu_q_h * q_h + mu$mu_d_gh * log(d_gh ^2) + 
                           mu$mu_d_gh * mu$mu_ppo_not_in_network * not_in_network * (1 - hmo) + 
                           mu$mu_d_gh * mu$mu_hmo_not_in_network * not_in_network * hmo 
                ) %>%
                mutate(u_ih = exp(u_ih)) %>% 
                group_by(patient_id) %>%
                mutate(pr_u = round(u_ih / sum(u_ih),3)) %>%
                arrange(patient_id, desc(pr_u)) %>% 
                select(patient_id,hosp_id, u_ih, pr_u)
        } else {
             df %>%
                mutate(
                    u_ih = mu$intercept + mu$mu_x_i * x_i + mu$mu_q_h * q_h + mu$mu_d_gh * log(d_gh^2) 
                ) %>%
                mutate(u_ih = exp(u_ih)) %>% 
                group_by(patient_id) %>%
                mutate(pr_u = round(u_ih / sum(u_ih),3)) %>%
                arrange(patient_id, desc(pr_u)) %>% 
                select(patient_id,hosp_id, u_ih, pr_u)
        }
        
    })
}

choice_utility <- 
    params %>% derive_choice_probabilities_utility(df = df_choice, network = FALSE) 
```


### Gravity Model

We have shown in earlier blog posts that the random utility framework (@eq-randutility0) can be cast in terms of a gravity model,

$$
F_{i h}=G \frac{\widetilde{X_i}^{\alpha_1} \widetilde{Q_h}^{\alpha_2}}{t_{i h}^{-\alpha_3}}
$$ {#eq-gravity0}
where $G$ is a normalizing constant, $\widetilde{X_i} = \exp(X_i)$, and $\widetilde{Q_h} = \exp(Q_h)$.

The function `derive_choice_probabilities_gravity()` takes as its inputs the parameters and data defined above and applies @eq-gravity0 to calculate these probabilities.

```{r}
#| code-fold: true
#| code-summary: Derive choice probabilities from gravity model framework
#| message: false
#| warning: false

derive_choice_probabilities_gravity <- function(params, df, network=TRUE) {
    with(params, {
        if (network) {
            df %>%
                mutate(t_ih = d_gh^2 * exp(mu$mu_hmo_not_in_network * not_in_network * hmo + mu$mu_ppo_not_in_network * not_in_network * (1-hmo))) %>%
                mutate(f_ih = exp(1)*exp(x_i)^mu$mu_x_i*exp(q_h)^mu$mu_q_h /  t_ih^{-mu$mu_d_gh}) %>% 
                group_by(patient_id) %>%
                mutate(pr_g = round(f_ih / sum(f_ih),3)) %>%
                arrange(patient_id, desc(pr_g)) %>% 
                select(patient_id,hosp_id, t_ih, f_ih, pr_g)
        } else {
            df %>%
                mutate(t_ih = d_gh^2)  %>%
                mutate(f_ih = exp(1)*exp(x_i)^mu$mu_x_i*exp(q_h)^mu$mu_q_h /  t_ih^{-mu$mu_d_gh}) %>% 
                group_by(patient_id) %>%
                mutate(pr_g = round(f_ih / sum(f_ih),3)) %>%
                arrange(patient_id, desc(pr_g)) %>% 
                select(patient_id,hosp_id, t_ih, f_ih, pr_g)
        }
    })
}

choice_gravity <- 
    params %>% derive_choice_probabilities_gravity(df = df_choice, network = FALSE) 
```

### Comparison of Choice Probabilities

We now demonstrate the equivalence of these two approaches in @tbl-compare.[^restrict] We see that the choice probabilities `pr_g` and `pr_u` are identical.

[^restrict]: To avoid a large number of rows where the choice probability is low due the hospital being hundreds of miles away, we limit the observations shown in  @tbl-compare to those within a close distance to each patient.

```{r}
#| code-fold: true
#| code-summary: Construct table
#| tbl-cap: Comparison of Choice Probabilities Under Random Utility and Gravity Model Frameworks in Simulated Data
#| label: tbl-compare

choice_gravity %>% 
    left_join(choice_utility,c("patient_id","hosp_id")) %>% 
    filter(pr_g>0.02) %>% 
    head(n=10) %>% 
    flextable(col_keys = c("patient_id","hosp_id","tmp1","t_ih","f_ih","pr_g","tmp2","u_ih","pr_u")) %>% 
    theme_vanilla() %>% 
    add_header_row(values = c("","","Gravity","","Random Utility"),colwidths = c(2,1,3,1,2)) %>% 
    empty_blanks() 
```


# Simulate

Our data generation functions are now nearly complete. However, after the steps above we have only defined the *probability* that a simulated patient chooses each alternative. We now round our our DGP simulation code by randomly selecting a hospital for each patient based on these probabilities. 

The entire process is captured in a function `simulate_dgp()` that simulates data (including hospital choices) under the DGP defined above. The function has an option for which choice framework (random utility, gravity) the data are generated under---though of course, as we saw above, both will yield identical choice probabilities. To be comprehensive, however, we will simulate two datasets with a common random seed to avoid stochastic differences between them: one under the random utility framework (@eq-randutility0) and one dataset under the gravity model framework (@eq-gravity0). 

```{r}
#| code-fold: true
#| code-summary: Data generation process simulation function code
#| message: false
#| warning: false

simulate_dgp <- function(params, has_network = TRUE, max_distance = 50, framework = "gravity") {
    hosp_ <- params %>% generate_hospital_attributes()
    dist_ <- params %>% generate_distance_data(hosp_data = hosp_)
    net_ <- params %>% generate_network_data(hosp_data = hosp_)
    plan_ <- params %>% generate_plan_data(network_data = net_)
    df_choice <- params %>% 
        combine_attributes(
            hosp_data = hosp_,
            location_data = location_,
            dist_data = dist_,
            plan_data = plan_,
            network_data = net_)  
    if (framework == "gravity") {
        tmp <-
            params %>% derive_choice_probabilities_gravity(df = df_choice, network = has_network)  %>%
            group_by(patient_id) %>%
            mutate(runif = runif(1)) %>%
            mutate(cum_pr = cumsum(pr_g)) %>%
            mutate(cum_pr = ifelse(row_number() == n(), 1, cum_pr)) %>%
            mutate(cum_pr0 = ifelse(row_number() == 1, 0, lag(cum_pr, 1))) %>%
            rowwise() %>%
            mutate(selected = as.integer(between(runif, cum_pr0, cum_pr))) %>%
            ungroup() %>%
            select(patient_id, hosp_id, truth = pr_g, selected) 
    } else if (framework == "random_utility") {
        tmp <-
            params %>% derive_choice_probabilities_utility(df = df_choice, network = has_network)  %>%
            group_by(patient_id) %>%
            mutate(runif = runif(1)) %>%
            mutate(cum_pr = cumsum(pr_u)) %>%
            mutate(cum_pr = ifelse(row_number() == n(), 1, cum_pr)) %>%
            mutate(cum_pr0 = ifelse(row_number() == 1, 0, lag(cum_pr, 1))) %>%
            rowwise() %>%
            mutate(selected = as.integer(between(runif, cum_pr0, cum_pr))) %>%
            ungroup() %>%
            select(patient_id, hosp_id, truth = pr_u, selected) 
    }

    df_choice %>% 
        left_join(tmp,c("patient_id","hosp_id")) %>% 
        ungroup() %>% 
        filter(d_gh <= max_distance) %>%
        select(patient_id, x_i, hosp_id, q_h, selected, d_gh, not_in_network, hmo, truth) %>%
        group_by(patient_id) %>%
        # Remove individuals whose selected hospital is > max_distance
        mutate(max_choice = max(selected)) %>%
        filter(max_choice == 1) %>% 
        select(-max_choice) %>% 
        # Remove hospitals that are never chosen
        group_by(hosp_id) %>% 
        mutate(max_choice = max(selected)) %>%
        filter(max_choice == 1) %>% ungroup()
}

set.seed(623)
df_gravity <- params %>%
    simulate_dgp(has_network = FALSE, framework = "gravity") 
set.seed(623)
df_utility <- params %>%
    simulate_dgp(has_network = FALSE, framework = "random_utility") 

# Collect results
df_res <- 
    df_gravity %>% select(patient_id,hosp_id,truth)
```

# Estimate 

We have several estimation options. First, we will consider the conditional logit as executed using the `mlogit` package in R. 

The `mlogit()` command requires that the data first be pre-processed:

```{r}
df_cl_utility <- 
    df_utility %>% 
    select(patient_id, hosp_id, selected, d_gh,q_h) %>% 
    dfidx(.)
```

We next fit the data with patient and hospital fixed effects. 

```{r}
fit_cl_utility = 
    mlogit(selected ~ log(d_gh^2), data =df_cl_utility)
```

```{r}
#| code-fold: true
#| code-summary: Table code

fit_cl_utility %>% tidy() %>% 
    filter(!grepl("Intercept",term)) %>% 
    flextable() %>% 
    flextable::add_footer_lines("Note: Coefficients on hospital fixed effects suppressed from table.")
```

Another option--to the extent we can measure all relevant hospital-level attributes (which we do here)---is to include hospital-level predictors intead of hospital fixed effects:

```{r}
fit_clx_utility = 
    mlogit(selected ~ log(d_gh^2) + q_h | 0, data =df_cl_utility)
```

```{r}
#| code-fold: true
#| code-summary: Table code
fit_clx_utility %>% tidy() %>% 
    flextable() 
```

Note that the estimated coefficients are quite close to the "truth" as defined in the `params` object above. 

We also obtain identical answers using the data simulated under the gravity model framework:

```{r}
#| code-fold: true
#| code-summary: Fit mlogit using gravity model data. 

df_cl_gravity <- 
    df_gravity %>% 
    select(patient_id, hosp_id, selected, d_gh, q_h) %>% 
    dfidx(.)

fit_cl_gravity = 
    mlogit(selected ~ log(d_gh^2), data =df_cl_gravity)

fit_cl_gravity %>% tidy() %>% 
    filter(!grepl("Intercept",term)) %>% 
    flextable() %>% 
    flextable::add_footer_lines("Note: Coefficients on hospital fixed effects suppressed from table.")

fit_clx_gravity = 
    mlogit(selected ~ log(d_gh^2) + q_h | 0, data =df_cl_gravity)

fit_clx_gravity %>% tidy() %>% 
    flextable() 
```

## Discrete Choice Using Cox Proportional Hazard Models

It has been shown (@gail1981likelihood) that the log-likelihood of a conditional logit is equivalent to that of a Cox proportional hazards model under a specific data structure. Intuitively, we can think of our choice problem as a matched case-control study where the cases are the chosen hospitals and the controls are the unchosen hospitals. We can re-cast our data as a case-control at a single time point, and fit a Cox proportional hazards model to estimate the instantaneous "hazard" of selecting each alternative as a function of covariates. In addition, we stratify the Cox model by `patient_id`, which effectively fits a patient fixed effect [@allison2014event].

```{r}
fit_cox_gravity <-
    coxph(
        formula =
            Surv(rep(1, nrow(df_gravity)), selected) ~ factor(hosp_id) + log(d_gh^2) + strata(patient_id),
        data = df_gravity,
        method = "efron",
        robust = TRUE
    )

fit_cox_utility <-
    coxph(
        formula =
            Surv(rep(1, nrow(df_gravity)), selected) ~ factor(hosp_id) + log(d_gh^2) + strata(patient_id),
        data = df_utility,
        method = "efron",
        robust = TRUE
    )
```

```{r}
#| code-fold: true
#| code-summary: Table code
fit_cox_utility %>% 
    tidy() %>% 
    filter(!grepl("hosp_id",term)) %>% 
    mutate_at(vars(-term),~round(.,3)) %>% 
    flextable() %>% 
    flextable::add_footer_lines("Note: Coefficients on hospital fixed effects suppressed from table.")

```

@tbl-comparison summarizes all the above and shows clearly that the gravity model and random utility frameworks--as estimated with a conditional logit *or* using a Cox model, yield identical coefficient values.

```{r}
#| code-fold: true
#| code-summary: Construct table
#| message: false
#| warning: false
#| tbl-cap: Comparison of Estimates Under Alternative Data Generation (Gravity, Random Utility) Processes and Estimation (conditional logit, Cox) Approaches
#| label: tbl-comparison

# Note: mlogit::mlogit() does not handle predicted values super well (which we'll look at later), so re-fitting using survival::clogit() instead; this yields identical results. 

fit_cl_gravity <-
    clogit(selected ~ factor(hosp_id) + log(d_gh^2) + strata(patient_id),
           data = df_gravity,
           method=c("efron"),
           robust = TRUE)
df_res$cl_gravity <- predict(fit_cl_gravity,type="expected")

fit_clx_gravity <- 
    clogit(selected ~  q_h + log(d_gh^2) + strata(patient_id) , 
           data = df_gravity, 
           method = c("efron"), 
           robust = TRUE)

fit_cl_utility <- 
    clogit(selected ~ factor(hosp_id) + log(d_gh^2) + strata(patient_id), 
           data = df_utility,
           method=c("efron"), 
           robust = TRUE)
df_res$cl_utility <- predict(fit_cl_utility,type="expected")

fit_clx_utility <- 
    clogit(selected ~  q_h + log(d_gh^2) + strata(patient_id) , 
           data = df_utility, 
           method = c("efron"), 
           robust = TRUE)


tmp_ <- fit_cl_gravity %>% tidy() %>% 
    filter(grepl("d_gh|q_h",term)) %>% 
    select(term, estimate,se = std.error) %>% 
    mutate(hosp_fixed = "X", patient_fixed = "X", framework = "Gravity", spec = "CL")  %>% 
    mutate(estimate = glue("{round(estimate,3)}")) %>% 
    mutate(se = glue("({round(se,3)})"))  %>% 
    mutate(n = row_number(), N = n()) %>% 
    gather(measure,value,-term,-n,-N) %>% 
    filter(measure == "estimate" | measure=="se" | (measure !="estimate" & measure != "se" & (n==N))) %>% 
    mutate(term = ifelse(measure!="estimate" & measure!="se","",term))           %>% 
    mutate(term = factor(term)) %>% 
    mutate(term = fct_relevel(term,"log(d_gh^2)")) %>% 
    arrange(term,measure) %>% 
    mutate(measure = factor(measure, levels = c("estimate","se","hosp_fixed","patient_fixed","framework","spec"))) %>% 
    arrange(term,measure) %>% 
    rename(cl_gravity = value) %>% 
    select(-n,-N)


tmp2_ <- fit_clx_gravity %>% tidy() %>% 
    filter(grepl("d_gh|q_h",term)) %>% 
    select(term, estimate,se = std.error) %>% 
    mutate(hosp_fixed = "-", patient_fixed = "X", framework = "Gravity", spec = "CL")  %>% 
    mutate(estimate = glue("{round(estimate,3)}")) %>% 
    mutate(se = glue("({round(se,3)})"))  %>% 
    mutate(n = row_number(), N = n()) %>% 
    gather(measure,value,-term,-n,-N) %>% 
    filter(measure == "estimate" | measure=="se" | (measure !="estimate" & measure != "se" & (n==N))) %>% 
    mutate(term = ifelse(measure!="estimate" & measure!="se","",term))           %>% 
    mutate(term = factor(term)) %>% 
    mutate(term = fct_relevel(term,"q_h")) %>%    
    mutate(term = fct_relevel(term,"log(d_gh^2)")) %>% 
    arrange(term,measure) %>% 
    mutate(measure = factor(measure, levels = c("estimate","se","hosp_fixed","patient_fixed","framework","spec"))) %>% 
    arrange(term,measure) %>% 
    rename(clx_gravity = value) %>% 
    select(-n,-N)

tmp2.b_ <- fit_cox_gravity %>% tidy() %>% 
    filter(grepl("d_gh|q_h",term)) %>% 
    select(term, estimate,se = robust.se) %>% 
    mutate(hosp_fixed = "-", patient_fixed = "X", framework = "Gravity", spec = "Cox")  %>% 
    mutate(estimate = glue("{round(estimate,3)}")) %>% 
    mutate(se = glue("({round(se,3)})"))  %>% 
    mutate(n = row_number(), N = n()) %>% 
    gather(measure,value,-term,-n,-N) %>% 
    filter(measure == "estimate" | measure=="se" | (measure !="estimate" & measure != "se" & (n==N))) %>% 
    mutate(term = ifelse(measure!="estimate" & measure!="se","",term))           %>% 
    mutate(term = factor(term)) %>% 
    mutate(term = fct_relevel(term,"log(d_gh^2)")) %>% 
    arrange(term,measure) %>% 
    mutate(measure = factor(measure, levels = c("estimate","se","hosp_fixed","patient_fixed","framework","spec"))) %>% 
    arrange(term,measure) %>% 
    rename(cox_gravity = value) %>% 
    select(-n,-N)

tmp3_ <- 
    fit_cl_utility %>% tidy() %>% 
    filter(grepl("d_gh|q_h",term)) %>% 
    select(term, estimate,se = std.error) %>% 
    mutate(hosp_fixed = "X", patient_fixed = "X", framework = "Random Utility", spec = "CL")  %>% 
    mutate(estimate = glue("{round(estimate,3)}")) %>% 
    mutate(se = glue("({round(se,3)})"))  %>% 
    mutate(n = row_number(), N = n()) %>% 
    gather(measure,value,-term,-n,-N) %>% 
    filter(measure == "estimate" | measure=="se" | (measure !="estimate" & measure != "se" & (n==N))) %>% 
    mutate(term = ifelse(measure!="estimate" & measure!="se","",term))           %>% 
    mutate(term = factor(term)) %>% 
    mutate(term = fct_relevel(term,"log(d_gh^2)")) %>% 
    arrange(term,measure) %>% 
    mutate(measure = factor(measure, levels = c("estimate","se","hosp_fixed","patient_fixed","framework","spec"))) %>% 
    arrange(term,measure) %>% 
    rename(cl_utility = value) %>% 
    select(-n,-N)

tmp3.b_ <- 
    fit_cox_utility %>% tidy() %>% 
    filter(grepl("d_gh|q_h",term)) %>% 
    select(term, estimate,se = robust.se) %>% 
    mutate(hosp_fixed = "X", patient_fixed = "X", framework = "Random Utility", spec = "Cox")  %>% 
    mutate(estimate = glue("{round(estimate,3)}")) %>% 
    mutate(se = glue("({round(se,3)})"))  %>% 
    mutate(n = row_number(), N = n()) %>% 
    gather(measure,value,-term,-n,-N) %>% 
    filter(measure == "estimate" | measure=="se" | (measure !="estimate" & measure != "se" & (n==N))) %>% 
    mutate(term = ifelse(measure!="estimate" & measure!="se","",term))           %>% 
    mutate(term = factor(term)) %>% 
    mutate(term = fct_relevel(term,"log(d_gh^2)")) %>% 
    arrange(term,measure) %>% 
    mutate(measure = factor(measure, levels = c("estimate","se","hosp_fixed","patient_fixed","framework","spec"))) %>% 
    arrange(term,measure) %>% 
    rename(cox_utility = value) %>% 
    select(-n,-N)


tmp4_ <- fit_clx_utility %>% tidy() %>% 
    filter(grepl("d_gh|q_h",term)) %>% 
    select(term, estimate,se = std.error) %>% 
    mutate(hosp_fixed = "-", patient_fixed = "X", framework = "Random Utility", spec = "CL")  %>% 
    mutate(estimate = glue("{round(estimate,3)}")) %>% 
    mutate(se = glue("({round(se,3)})"))  %>% 
    mutate(n = row_number(), N = n()) %>% 
    gather(measure,value,-term,-n,-N) %>% 
    filter(measure == "estimate" | measure=="se" | (measure !="estimate" & measure != "se" & (n==N))) %>% 
    mutate(term = ifelse(measure!="estimate" & measure!="se","",term))           %>% 
    mutate(term = factor(term)) %>% 
    mutate(term = fct_relevel(term,"q_h")) %>%    
    mutate(term = fct_relevel(term,"log(d_gh^2)")) %>% 
    arrange(term,measure) %>% 
    mutate(measure = factor(measure, levels = c("estimate","se","hosp_fixed","patient_fixed","framework","spec"))) %>% 
    arrange(term,measure) %>% 
    rename(clx_utility = value) %>% 
    select(-n,-N)

res_table <- 
    tmp_ %>% 
    full_join(tmp2_,c("term","measure")) %>% 
    full_join(tmp2.b_,c("term","measure")) %>% 
    full_join(tmp3_,c("term","measure")) %>% 
    full_join(tmp3.b_,c("term","measure")) %>% 
    full_join(tmp4_,c("term","measure")) %>% 
    select(term,measure,cl_gravity,cl_utility,cox_gravity,cox_utility,clx_gravity,clx_utility) %>% 
    mutate(measure = factor(measure, levels = c("estimate","se","hosp_fixed","patient_fixed","framework","spec"))) %>% 
    mutate(term = factor(term)) %>% 
    mutate(term = fct_relevel(term,"q_h")) %>%    
    mutate(term = fct_relevel(term,"log(d_gh^2)")) %>% 
    arrange(term,measure) %>% 
    select(measure,term,everything()) %>% 
    
    mutate(measure = factor(measure)) %>% 
    mutate(measure = fct_recode(measure,  "Hospital Fixed Effects" = "hosp_fixed", "Patient Fixed Effects" = "patient_fixed",
                                "Choice Framework for Data Generation Process" = "framework", "Specification" = "spec")) %>% 
    mutate(measure = coalesce(measure,term)) %>% 
    mutate(term = ifelse(measure=="se","",paste0(term))) %>% 
    mutate(measure = ifelse(measure %in% c("estimate","se"),"",paste0(measure))) %>% 
    mutate(measure = paste0(measure,term)) %>% 
    select(-term) 

res_table %>% 
    mutate(Truth = with(params, sprintf("%.1f",c(mu$mu_d_gh,NA,mu$mu_q_h,NA,NA,NA,NA,NA)))) %>% 
    mutate(Truth = ifelse(is.na(Truth)|Truth=="NA","",Truth)) %>% 
    flextable() %>% 
    width(j = 1, width=2)  %>% 
    set_header_labels(
    measure = "",
    cl_gravity= "(1)",
    cl_utility = "(2)",
    cox_gravity = "(3)",
    cox_utility = "(4)",
    clx_gravity = "(5)",
    clx_utility = "(6)")
```

```{r}
#| code-fold: true
#| code-summary: Construct figure
#| message: false
#| warning: false
#| label: tbl-predicted
#| tbl-cap:  Predicted Choice Probabilities vs. Truth

baseline_hazard_gravity <- basehaz(fit_cox_gravity) %>% as_tibble() %>% janitor::clean_names() %>% select(-time) %>% rename(hazard_gravity = hazard, strata_gravity = strata)
baseline_hazard_utility <- basehaz(fit_cox_gravity) %>% as_tibble() %>% janitor::clean_names() %>% select(-time) %>% rename(hazard_utility = hazard,
                                                                                                                            strata_utility = strata)
df_res$lp_cox_gravity <- predict(fit_cox_gravity, type = "lp")
df_res$lp_cox_utility <- predict(fit_cox_utility, type = "lp")
df_res$strata_gravity = model.frame(fit_cox_gravity) %>% as_tibble() %>% janitor::clean_names() %>% pull(strata_patient_id)
df_res$strata_utility = model.frame(fit_cox_utility) %>% as_tibble() %>% janitor::clean_names() %>% pull(strata_patient_id)
df_res <- 
    df_res %>% left_join(baseline_hazard_gravity,"strata_gravity") %>% 
    left_join(baseline_hazard_utility,"strata_utility")

foo <- 
    df_res %>% 
    mutate(cox_gravity = exp(lp_cox_gravity)*hazard_gravity) %>% 
    mutate(cox_utility = exp(lp_cox_utility)*hazard_utility) %>% 
    group_by(patient_id) %>% 
    mutate(cox_gravity = cox_gravity/sum(cox_gravity))  %>% 
    mutate(cox_utility = cox_utility/sum(cox_utility))  %>% 
    select(patient_id,hosp_id,truth,cl_gravity,cl_utility,cox_gravity,cox_utility)

foo %>% 
    gather(model,p_choice,-patient_id,-hosp_id,-truth) %>% 
    mutate(model = case_when(model=="cl_gravity" ~ "Conditional Logit - Gravity",
                             model=="cl_utility" ~ "Conditional Logit - Random Utillity",
                             model=="cox_gravity" ~ "Cox Proportional Hazards - Gravity",
                             model=="cox_utility" ~ "Cox Proportional Hazards - Random Utility")) %>% 
    ggplot(aes(x = truth, y = p_choice, colour = model)) + #geom_smooth() + 
    hrbrthemes::theme_ipsum() + 
    geom_abline(intercept = 0, slope = 1, lty=2) + 
    theme(legend.position = "bottom") + 
    ggsci::scale_colour_nejm(name="") +
    labs(x = "Chioce Probability: Truth", y = "Choice Probability: Prediccted") + 
    geom_point(alpha=0.2)

```

# References


