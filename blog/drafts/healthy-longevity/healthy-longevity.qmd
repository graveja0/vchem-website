---
title: "Healthy Longevity"
format: html
editor_options: 
  chunk_output_type: console
---

```{r setup}
#| echo: false
#| warning: false
#| message: false
#| 
library(tidyverse)
library(MASS)
library(expm)
library(knitr)
library(kableExtra)
options(scipen = 5) 
transpose <- purrr::transpose
select <- dplyr::select

vec <-  # a simple function to return the vec of an array
    function(x) {
        y <- c(x)
        return(y)
    }

vecperm <- 
    # vecperm
    # function to calculate the vec permutation matrix K of index m,n
    # let X be a m x n matrix, and X' the transpose of X
    # then K satisfies 
    # vec(X') = K*vec(X)
    function(m, n) {
        K <- matrix(0, m * n, m * n)
        a <- matrix(0, m, n)
        
        for (i in 1:m) {
            for (j in 1:n) {
                e <- a
                e[i, j] <- 1
                K <- K + kronecker(e, t(e))
            }
        }
        
        return(K)
    }


gen_wcc <- function (n_cycles, method = c("Simpson1/3", "half-cycle", "none")) 
{
    if (n_cycles <= 0) {
        stop("Number of cycles should be positive")
    }
    method <- match.arg(method)
    n_cycles <- as.integer(n_cycles)
    if (method == "Simpson1/3") {
        v_cycles <- seq(1, n_cycles + 1)
        v_wcc <- ((v_cycles%%2) == 0) * (2/3) + ((v_cycles%%2) != 
                                                     0) * (4/3)
        v_wcc[1] <- v_wcc[n_cycles + 1] <- 1/3
    }
    if (method == "half-cycle") {
        v_wcc <- rep(1, n_cycles + 1)
        v_wcc[1] <- v_wcc[n_cycles + 1] <- 0.5
    }
    if (method == "none") {
        v_wcc <- rep(1, n_cycles + 1)
    }
    return(v_wcc)
}
```

# Parameterize

```{r parameterize}
#| echo: false
#| warning: false
#| message: false

# Parameterize
params <- list(
    tx_names = c("natural_history"), 
    n_tx = 1,
    
    tr_names = c("Healthy","Sick","Sicker"),
    ab_names = c("DeadBG","DeadDisease"),
    
    omega = 250,
    r_ann = 0.03,
    Delta_t = 1,
    age0 = 20,
    s0T = c(1,0,0,0,0),
    
    rHS1 = 0.05,
    rD = 0.01,
    rS1S2 = 0.12,
    rS1D = 0.02,
    rS2D = 0.03,
    
    uS1 = 0.95,
    uS2 = 0.8,
    uD = 0,
    uH = 1,
    
    dwS1 = 0.1,
    dwS2 = 0.2,
    
    ExR = 
        # Global Burden of Disease Collaborative Network. Global Burden of Disease Study 
        # 2019 (GBD 2019) Reference Life Table. Seattle, United States of America: 
        # Institute for Health Metrics and Evaluation (IHME), 2020
        tibble::tribble(
            ~Age, ~Life.Expectancy,
            0L,       88.8718951,
            1L,      88.00051053,
            5L,      84.03008056,
            10L,      79.04633476,
            15L,       74.0665492,
            20L,      69.10756792,
            25L,      64.14930031,
            30L,       59.1962771,
            35L,      54.25261364,
            40L,      49.31739311,
            45L,      44.43332057,
            50L,      39.63473787,
            55L,      34.91488095,
            60L,      30.25343822,
            65L,      25.68089534,
            70L,      21.28820012,
            75L,      17.10351469,
            80L,      13.23872477,
            85L,      9.990181244,
            90L,      7.617724915,
            95L,      5.922359078
        ) 
)

params <- with(params,modifyList(params,list(
    alpha = length(ab_names),
    tau = length(tr_names), 
    s = length(tr_names)*omega + length(ab_names), #total number of states;s=τω+α
    r_Delta_t = r_ann * Delta_t ,
    cycles = omega/Delta_t,
    ages = (0:(omega/Delta_t))*Delta_t + age0,
    fExR <- function(x) pmax(0,unname(Hmisc::approxExtrap(ExR$Age, ExR$Life.Expectancy,xout = x)$y)),
    # Age transition Matrix
    D = {
        # Create diagonal age advancement matrix
        D <- matrix(0, omega, omega)
        vec <- rep(1, omega)
        D[row(D) == col(D)] <- vec
        D
    },
    # Natural History Transition Rate Matrix
    mR_nh = 
        matrix(c(
        -(rHS1 + rD), rHS1, 0, rD, 0 ,
        0, -(rS1S2 + rS1D + rD), rS1S2, (rS1D + rD), rS1D,
        0, 0, -(rS2D + rD), (rS2D + rD), rS2D,
        0,0,0,0,0,
        0,0,0,0,0),
        nrow = 5, 
        ncol = 5,
        byrow=TRUE, 
        dimnames = list(c(tr_names,ab_names),
                        c(tr_names,ab_names)
        ))
)))

params <- with(params,modifyList(params,list(
    # note that because we have a time homogeneous model here, we do not need to do this separately
    # by cycle. but in principle, we could create a list object with each of these matrices defined
    # for each time cycle. 

    mR = array(as.vector(mR_nh), dim = c(length(tr_names)+ length(ab_names),length(tr_names)+ length(ab_names),length(tx_names)),
          dimnames = list(c(tr_names,ab_names),c(tr_names,ab_names),tx_names)) %>% 
            apply(.,3,function(x) x, simplify=FALSE)
)))

params <- with(params,modifyList(params,list(
    mV = mR %>% map(~({
            m <- .x[tr_names,tr_names] 
            diag(m) <- 0
            t(m)
        })),
    mQ = mR %>% map(~({
        V = t(.x[tr_names,tr_names])
        M = t(.x[tr_names,ab_names])
        zero_ <- matrix(0, nrow = length(tr_names)+length(ab_names), ncol = length(ab_names))
        tmp <- cbind(rbind(V,M),zero_)
        dimnames(tmp) <- list(c(tr_names,ab_names),c(tr_names,ab_names))
        tmp
    }))
)))

params <- with(params,modifyList(params,list(
    mP = mQ %>% map(~({
        expm(.x * Delta_t)
    }))
)))

params <- with(params,modifyList(params,list(
    mU = mP %>% map(~({
        .x[tr_names,tr_names]
    })),
    mM = mP %>% map(~({
        .x[ab_names,tr_names]
    })),
    bbD_ = kronecker(diag(tau), D)
)))

params <- with(params,modifyList(params,list(
    bbU_ =  (1:omega %>% map(~ (mU))) %>%
            transpose() %>%
            map(~ (bdiag(.x))),
    K = vecperm(tau, omega)
)))

params <- with(params, modifyList(params, list(
    mUtilde = bbU_ %>% map( ~ ({
        t(K) %*% bbD_ %*% K %*% .x
    })),
    mMtilde = (1:omega %>% map( ~ (mM)))  %>%
            transpose() %>% 
        map(~({
        do.call(cbind,.x) 
    }))
)))

params <- with(params,modifyList(params,list(
    mPtilde =  map2(mUtilde, mMtilde,  ~ ({
            rbind(cbind(.x, matrix(0, tau * omega, alpha)) ,
                  cbind(.y, diag(alpha)))
        }))
)))
```


```{r}
trace = with(params,({
    0:(omega) %>% 
    map_df(~({
        as.data.frame(params$s0T %*% (t(mP$natural_history) %^% .x))
    })) %>% 
    as.matrix()
})) 
    
le_ = matrix(c(1,
              1 ,
              1,
              0,
              0),
            dimnames = list(c(
                c(params$tr_names,params$ab_names)
            ), c("LE")))

res_le = c("Simpson1/3", "half-cycle", "none") %>% map(~sum((trace %*% le_)*gen_wcc(params$omega,method = .x))) %>% 
    set_names(c("Simpson1/3", "half-cycle", "none")) %>% unlist() %>% rev()

qaly_ <- with(params,{
  matrix(c(uH,uS1,uS2,0,0), 
         dimnames = list(c(tr_names,ab_names)))
})

res_qaly <- c("Simpson1/3", "half-cycle", "none") %>% map(~sum((trace %*% qaly_)*gen_wcc(params$omega,method = .x))) %>% 
    set_names(c("Simpson1/3", "half-cycle", "none")) %>% unlist() %>% rev()

```

```{r}

calculate_fundamental_matrix <- function(params) {
  N <- with(params,({
    mUtilde %>% map(~solve(diag(tau * omega) - .x)) 
  }))
  return(N)
}

calculate_rewards <- function(params, H, V) {
     with(params, ({
        Z <- # eq. 17
            cbind(diag(tau * omega), matrix(0, nrow = tau * omega, ncol = alpha))
        e = rep(1,s)
        
        h <- vec(H) %>% as.matrix()
        H_c = 1 - H
        h_c = vec(H_c) %>% as.matrix()
        
        a_ = 0.5 # transitions happen, on average, 1/2 way through the time step

        v = vec(V) %>% as.matrix()
        

        B1 = h %*% t(v) + ((1/2) * (h_c %*% t(v))) + ((1/2) * (v %*% t(h_c)))  # Eq 46
        B2 = h %*% t(v) + ((1/2^2) * (h_c %*% t(v))) + ((1/2^2) * (v %*% t(h_c)))  # Eq 47
        C1 = with(params,(1/2)*(rep(1,alpha) %*% t(v))) # Eq 48
        C2 = with(params,(1/2)*(rep(1,alpha) %*% t(v))) # Eq 48
        
        # B1 = h %*% t(h) + (a_ * (h_c %*% t(h))) + ((1 - a_) * (h %*% t(h_c))) # EQ. 29
        # C1 = with(params,a_ * (rep(1,alpha) %*% t(h))) # Eq. 31
        R1 = # Eq. 12
                rbind(cbind(B1, matrix(0, tau * omega, alpha)) ,
                  cbind(C1, diag(alpha)))
        R2 = R1 * R1
        R3 = R1 * R1 * R1
        R4 = R1 * R1 * R1
        

        rho <-
          map2(mUtilde, mPtilde,  ~ ({
            N = solve(diag(tau * omega) - .x)
            P = .y
            rho1_ <- (t(N) %*% (Z %*% t(P * R1))) %*% e
            rho2_ <-
              N %*% (Z %*% t(.y * R1) %*% e + 2 * t(.x * B1) %*% rho1_)
            B2 <- R2[1:(tau * omega), 1:(tau * omega)]
            rho3_ <- t(N) %*% (Z %*% ((t(.y * R3) %*% e)) + 3 * (t(.x * B2) %*% rho1_) + 3 * (t(.x * B1) %*% rho2_))
            list(rho1 = rho1_, rho2 = rho2_ , rho3 = rho3_)
          }))

        return(rho)
     })) 
} 

# Define Reward Matrices
mH_LE <- matrix(1,nrow = length(params$tr_names), ncol=params$omega)
mV_QALY <- matrix(0, nrow = length(params$tr_names), ncol = params$omega)
mV_QALY[1,] = rep(params$uH, params$omega)
mV_QALY[2,] = rep(params$uS1, params$omega)
mV_QALY[3,] = rep(params$uS2, params$omega)

le <- params %>% calculate_rewards(H = mH_LE, V = mH_LE) 

healthy_longevity_le <- 
  le %>% map(~({
    tmp <- (kronecker(t(c(1,rep(0,params$omega-1))) ,diag(params$tau)) %*% .x[["rho1"]]) # healthy (from initial_age but no others)
    rownames(tmp) <- params$tr_names
    tmp
})) 
res_le <- c(res_le, "healthy_longevity" = unname(healthy_longevity_le[[1]][1,1]))

qaly <- params %>% calculate_rewards(H = mH_LE, V = mV_QALY) 

#m_reward <- (kronecker(diag(params$omega),t(c(1,0,0))) %*% rho1)[1] # healthy as a function of age

healthy_longevity_qaly <- 
  qaly %>% map(~({
    tmp <- (kronecker(t(c(1,rep(0,params$omega-1))) ,diag(params$tau)) %*% .x[["rho1"]]) # healthy (from initial_age but no others)
    rownames(tmp) <- params$tr_names
    tmp
}))
res_qaly <- c(res_qaly, "healthy_longevity" = unname(healthy_longevity_qaly[[1]][1,1]))
```

```{r}
tibble(method = names(res_le), life_expectancy = res_le, qaly = res_qaly) %>% 
  kable() %>% 
  kable_styling()
```

```{r}
calculate_fundamental_matrix <- function(params) {
  N <- with(params,({
    mUtilde %>% map(~solve(diag(tau * omega) - .x)) 
  }))
  return(N)
}
N <- params %>% calculate_fundamental_matrix()

eta1 <- 
    calculate_fundamental_matrix(params) %>% map(~({
      t(rep(1,params$tau * params$omega)) %*% .x
    }))  



```

